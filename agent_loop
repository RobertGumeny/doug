#!/usr/bin/env bash
# agent_loop - Main orchestration loop for autonomous coding
#
# Usage: ./agent_loop [iterations]
#   iterations: Maximum number of tasks to process (default: 5)
#
# This script is copied to your project root during setup.
# It sources the agent-orchestrator framework from ./orchestrator/ subdirectory.

set -o pipefail

# Get project root (where this script lives)
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ORCHESTRATOR_DIR="$PROJECT_ROOT/orchestrator"

# Verify orchestrator directory exists
if [ ! -d "$ORCHESTRATOR_DIR" ]; then
    echo "Error: orchestrator/ directory not found at $ORCHESTRATOR_DIR"
    echo "This script expects the agent-orchestrator framework to be in ./orchestrator/"
    exit 1
fi

# Source all modules in dependency order
source "$ORCHESTRATOR_DIR/lib/config.sh"
source "$ORCHESTRATOR_DIR/lib/logging.sh"
source "$ORCHESTRATOR_DIR/core/project.sh"
source "$ORCHESTRATOR_DIR/core/dependencies.sh"
source "$ORCHESTRATOR_DIR/core/verification.sh"
source "$ORCHESTRATOR_DIR/core/changelog.sh"
source "$ORCHESTRATOR_DIR/core/git.sh"
source "$ORCHESTRATOR_DIR/core/metrics.sh"
source "$ORCHESTRATOR_DIR/core/state.sh"
source "$ORCHESTRATOR_DIR/agent/dispatch.sh"
source "$ORCHESTRATOR_DIR/agent/parse.sh"
source "$ORCHESTRATOR_DIR/handlers/success.sh"
source "$ORCHESTRATOR_DIR/handlers/failure.sh"
source "$ORCHESTRATOR_DIR/handlers/bug.sh"
source "$ORCHESTRATOR_DIR/handlers/epic.sh"

# Parse arguments
MAX_ITERATIONS=${1:-5}
ITERATION=0

main() {
    check_dependencies
    bootstrap_from_tasks
    read_task_info
    handle_early_exit
    ensure_project_ready
    validate_yaml_structure
    ensure_epic_branch "$CURRENT_EPIC"
    initialize_task_pointers
    validate_state_sync

    log_section "Starting Agent Loop (Max iterations: $MAX_ITERATIONS)"

    while [[ $ITERATION -lt $MAX_ITERATIONS ]]; do
        ((ITERATION++))

        read_task_info

        # Increment attempt at the BEGINNING (use 1-based indexing)
        increment_attempts

        # Re-read task info to get updated attempt count
        read_task_info

        echo ""
        log_info "Iteration $ITERATION / $MAX_ITERATIONS"
        log_info "Epic: $CURRENT_EPIC"
        log_info "Task: $TASK_ID ($TASK_TYPE) - Attempt $TASK_ATTEMPTS"
        echo "----------------------------------------------"

        # Mark task as IN_PROGRESS
        if [[ "$TASK_TYPE" != "bugfix" && "$TASK_TYPE" != "documentation" && "$TASK_TYPE" != "manual_review" ]]; then
            local current_status=$(yq eval ".epic.tasks[] | select(.id == \"$TASK_ID\") | .status" "$TASKS_FILE")
            if [[ "$current_status" == "TODO" ]]; then
                update_task_status "$TASK_ID" "IN_PROGRESS"
            fi
        fi

        # Create session directory and pre-create session file
        mkdir -p "$LOGS_DIR/sessions/$CURRENT_EPIC"
        SESSION_FILE=$(create_session_file "$CURRENT_EPIC" "$TASK_ID" "$TASK_ATTEMPTS")

        # Run agent (pass 1-based attempt number and session file)
        run_agent "$TASK_TYPE" "$TASK_ID" "$TASK_ATTEMPTS" "$SESSION_FILE"

        # Parse session result (use same attempt number)
        if ! parse_session_result "$CURRENT_EPIC" "$TASK_ID" "$TASK_ATTEMPTS"; then
            log_error "Failed to parse session result"
            fatal "Cannot continue without valid session result"
        fi

        # Calculate duration (orchestrator exclusively manages timing)
        TASK_END_TIME=$(date +%s)
        TASK_DURATION=$((TASK_END_TIME - TASK_START_TIME))
        export TASK_DURATION
        log_info "Task duration: ${TASK_DURATION}s"

        echo ""
        log_info "Session outcome: ${SESSION_RESULT[outcome]}"
        echo "----------------------------------------------"

        # Handle outcome
        case "${SESSION_RESULT[outcome]}" in
            SUCCESS)
                handle_success "$TASK_ID" "$TASK_TYPE" "$CURRENT_EPIC"
                result=$?

                if [[ $result -eq 2 ]]; then
                    # Epic complete
                    if ! handle_epic_complete "$CURRENT_EPIC"; then
                        log_error "Epic finalization commit failed. Check git status for uncommitted changes."
                        exit 1
                    fi
                    exit 0
                elif [[ $result -eq 0 ]]; then
                    log_success "Continuing to next task"
                else
                    log_error "Verification failed, retrying..."
                fi
                ;;

            BUG)
                handle_bug "$TASK_ID" "$CURRENT_EPIC" "$TASK_TYPE"
                ;;

            FAILURE)
                handle_failure "$TASK_ID" "$TASK_TYPE" "$CURRENT_EPIC"
                ;;

            EPIC_COMPLETE)
                if ! handle_epic_complete "$CURRENT_EPIC"; then
                    log_error "Epic finalization commit failed. Check git status for uncommitted changes."
                    exit 1
                fi
                exit 0
                ;;

            *)
                log_error "Unknown outcome: ${SESSION_RESULT[outcome]}"
                fatal "Invalid session outcome"
                ;;
        esac

        echo ""
    done

    echo ""
    log_warning "Maximum iterations ($MAX_ITERATIONS) reached."
    log_info "Progress saved. Run again to continue."
    log_info "Current state:"
    log_info "  Epic: $CURRENT_EPIC"
    log_info "  Next task: $TASK_TYPE / $TASK_ID"
    log_info "  Attempts: $TASK_ATTEMPTS"
    exit 0
}

main
